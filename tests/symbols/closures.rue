test fn no_captures() -> fn() -> Int {
    fn() => 42
}

test fn one_capture() -> fn() -> Int {
    let num = 42;
    fn() => num + num
}

test fn one_inline_capture() -> fn() -> Int {
    inline let num = 42;
    fn() => num + num
}

test fn two_captures() -> fn() -> Int {
    let a = 42;
    let b = 34;
    fn() => a * a + b * b
}

test fn two_inline_captures() -> fn() -> Int {
    inline let a = 42;
    inline let b = 34;
    fn() => a * a + b * b
}

test fn adder_inline() -> Int {
    let num = 10;
    let adder = create_adder(num);
    adder(20)
}

test fn adder_non_inline() -> Int {
    let num = 10;
    let adder_1 = create_adder(num * 2);
    let adder_2 = create_adder(num * 3);
    adder_1(20) + adder_2(30) + adder_1(40) + adder_2(50)
}

test fn nested_closures() -> Int {
    let num = 10;
    let result = fn() => fn() => num + (fn() => num + 1)();
    result()() + result()()
}

test fn auto_extern() -> Int {
    let closure = fn(a: Int, b: Int, c: Int) => a + b + c;
    closure(1, 2, 3) + closure(4, 5, 6)
}

// TODO: This is a regression test to ensure tree captures are disabled for closures
// It was breaking due to the Closure LIR generation being sequential
// We can add support for tree captures for closures in the future
test fn closure_sequential_captures() {
    let tree_params = tree_params;
    let a = tree_params(1, 2, 3, 4);
    let tree_params_spread = tree_params_spread;
    let b = tree_params_spread(1, 2, 3, ...4);
    assert a == 76;
    assert b == 76;
}

fn create_adder(a: Int) -> fn(b: Int) -> Int {
    fn(b: Int) => a + b
}

const CAPTURE_1: Int = 42;
const CAPTURE_2: Int = 34;

fn tree_params(a: Int, b: Int, c: Int, d: Int) -> Int {
    assert a == 1;
    assert b == 2;
    assert c == 3;
    assert d == 4;
    CAPTURE_1 + CAPTURE_2
}

fn tree_params_spread(a: Int, b: Int, c: Int, ...d: Int) -> Int {
    assert a == 1;
    assert b == 2;
    assert c == 3;
    assert d == 4;
    CAPTURE_1 + CAPTURE_2
}
