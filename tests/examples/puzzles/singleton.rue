// This puzzle has not been audited or tested, and is for example purposes only.

struct Singleton {
  mod_hash: Bytes32,
  launcher_id: Bytes32,
  ...launcher_puzzle_hash: Bytes32,
}

struct LineageProof {
  parent_parent_coin_id: Bytes32,
  parent_inner_puzzle_hash: Bytes32,
  parent_amount: Int,
}

struct EveProof {
  parent_parent_coin_id: Bytes32,
  parent_amount: Int,
}

type Proof = LineageProof | EveProof;

struct Melt {
  op = 51,
  puzzle_hash = nil,
  amount = -113,
}

type SingletonCondition = Condition | Melt;

fn main(
  singleton: Singleton,
  inner_puzzle: fn(...solution: Any) -> List<SingletonCondition>,
  proof: Proof,
  my_amount: Int,
  inner_solution: Any,
) -> List<Condition> {
  assert my_amount % 2 == 1;
  
  let parent_id = if proof is EveProof {
    calculate_coin_id(
      proof.parent_parent_coin_id,
      singleton.launcher_puzzle_hash,
      proof.parent_amount,
    )
  } else {
    calculate_coin_id(
      proof.parent_parent_coin_id,
      curry_singleton_hash(
        singleton,
        proof.parent_inner_puzzle_hash,
      ),
      proof.parent_amount,
    )
  };
  
  let assert_parent = verify_lineage_proof(
    singleton,
    parent_id,
    proof is LineageProof,
  );
  
  let inner_conditions = inner_puzzle(...inner_solution);
  
  let conditions = morph_conditions(singleton, inner_conditions, false);
  
  [assert_parent, ...conditions]
}

fn curry_singleton_hash(
  singleton: Singleton,
  inner_puzzle_hash: Bytes32,
) -> Bytes32 {
  curry_tree_hash(
    singleton.mod_hash,
    tree_hash(singleton as Any),
    inner_puzzle_hash,
  )
}

fn verify_lineage_proof(
  singleton: Singleton,
  parent_id: Bytes32,
  is_not_launcher: Bool,
) -> AssertMyParentId {
  assert is_not_launcher || parent_id == singleton.launcher_id;

  AssertMyParentId {
    parent_id: parent_id,
  }
}

fn morph_conditions(
  singleton: Singleton,
  conditions: List<SingletonCondition>,
  found_odd_output: Bool,
) -> List<Condition> {
  if conditions is nil {
    assert found_odd_output;
    return nil;
  }
  
  let condition = conditions.first;
  
  if condition is CreateCoin | Melt {
    assert !found_odd_output;
    
    if condition is Melt {
      return morph_conditions(singleton, conditions.rest, true);
    }
    
    let condition = morph_condition(condition, singleton);
    let rest = morph_conditions(singleton, conditions.rest, true);
    
    return [condition, ...rest];
  }
  
  let rest = morph_conditions(singleton, conditions.rest, found_odd_output);

  [condition, ...rest]
}

fn morph_condition(condition: CreateCoin, singleton: Singleton) -> CreateCoin {
  let puzzle_hash = curry_singleton_hash(singleton, condition.puzzle_hash);

  CreateCoin {
    puzzle_hash: puzzle_hash,
    amount: condition.amount,
    memos: condition.memos,
  }
}
