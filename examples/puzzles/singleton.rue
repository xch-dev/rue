// This puzzle has not been audited or tested, and is for example purposes only.

struct Singleton {
  mod_hash: Bytes32,
  launcher_id: Bytes32,
  ...launcher_puzzle_hash: Bytes32,
}

struct LineageProof {
  parent_parent_coin_id: Bytes32,
  parent_inner_puzzle_hash: Bytes32,
  parent_amount: Int,
}

struct EveProof {
  parent_parent_coin_id: Bytes32,
  parent_amount: Int,
}

type Proof = LineageProof | EveProof;

struct Melt {
  op = 51,
  puzzle_hash = nil,
  amount = -113,
}

type SingletonCondition = Condition | Melt;

fn main(
  singleton: Singleton,
  inner_puzzle: fn(...solution: Any) -> List<SingletonCondition>,
  proof: Proof,
  my_amount: Int,
  inner_solution: Any,
) -> List<Condition> {
  assert my_amount % 2 == 1;
  
  let parent_id = if proof is EveProof {
    coinid(
      proof.parent_parent_coin_id,
      singleton.launcher_puzzle_hash,
      proof.parent_amount,
    )
  } else {
    coinid(
      proof.parent_parent_coin_id,
      curry_singleton_hash(
        singleton,
        proof.parent_inner_puzzle_hash,
      ),
      proof.parent_amount,
    )
  };
  
  let assert_amount = AssertMyAmount {
    amount: my_amount,
  };
  
  let assert_parent = verify_lineage_proof(
    singleton,
    parent_id,
    ...proof is LineageProof,
  );
  
  let inner_conditions = inner_puzzle(...inner_solution);
  
  let conditions = morph_conditions(singleton, inner_conditions, ...false);
  
  [assert_amount, assert_parent, ...conditions]
}

inline fn curry_singleton_hash(
  singleton: Singleton,
  inner_puzzle_hash: Bytes32,
) -> Bytes32 {
  curry_tree_hash(singleton.mod_hash, ...[tree_hash(singleton), inner_puzzle_hash])
}

fn verify_lineage_proof(
  singleton: Singleton,
  parent_id: Bytes32,
  ...is_not_launcher: Bool,
) -> AssertMyParentId {
  assert is_not_launcher || parent_id == singleton.launcher_id;

  AssertMyParentId {
    parent_id: parent_id,
  }
}

fn morph_conditions(
  singleton: Singleton,
  conditions: List<SingletonCondition>,
  ...found_odd_output: Bool,
) -> List<Condition> {
  if conditions is nil {
    assert found_odd_output;
    return nil;
  }
  
  let condition = conditions.first;
  
  if condition is CreateCoin | Melt {
    assert !found_odd_output;
    
    if condition is Melt {
      return morph_conditions(singleton, conditions.rest, ...true);
    }
    
    let condition = morph_condition(condition, ...singleton);
    let rest = morph_conditions(singleton, conditions.rest, ...true);
    
    return [condition, ...rest];
  }
  
  let rest = morph_conditions(singleton, conditions.rest, ...found_odd_output);

  [condition, ...rest]
}

inline fn morph_condition(condition: CreateCoin, ...singleton: Singleton) -> CreateCoin {
  let puzzle_hash = curry_singleton_hash(singleton, condition.puzzle_hash);

  CreateCoin {
    puzzle_hash: puzzle_hash,
    amount: condition.amount,
    memos: condition.memos,
  }
}

test fn tests() {
  let parent_parent_coin_id = sha256("parent_parent_coin_id");
  let launcher_puzzle_hash = sha256("launcher_puzzle");
  let launcher_id = coinid(parent_parent_coin_id, launcher_puzzle_hash, 0);

  let singleton = Singleton {
    mod_hash: tree_hash(main),
    launcher_id: launcher_id,
    launcher_puzzle_hash: launcher_puzzle_hash,
  };

  let inner_puzzle = fn(...solution: List<SingletonCondition>) => solution;

  let proof = EveProof {
    parent_parent_coin_id: parent_parent_coin_id,
    parent_amount: 0,
  };

  let p2_puzzle_hash = sha256("p2_puzzle_hash");

  let conditions = main(
    singleton,
    inner_puzzle,
    proof,
    1,
    [CreateCoin {
      puzzle_hash: p2_puzzle_hash,
      amount: 1,
    }],
  );

  assert tree_hash(conditions) == tree_hash([
    AssertMyAmount { amount: 1 },
    AssertMyParentId { parent_id: launcher_id },
    CreateCoin {
      puzzle_hash: curry_singleton_hash(singleton, p2_puzzle_hash),
      amount: 1,
    },
  ]);
}
