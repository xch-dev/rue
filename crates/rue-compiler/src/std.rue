export inline const REMARK: 1 = 1;
export inline const AGG_SIG_PARENT: 43 = 43;
export inline const AGG_SIG_PUZZLE: 44 = 44;
export inline const AGG_SIG_AMOUNT: 45 = 45;
export inline const AGG_SIG_PUZZLE_AMOUNT: 46 = 46;
export inline const AGG_SIG_PARENT_AMOUNT: 47 = 47;
export inline const AGG_SIG_PARENT_PUZZLE: 48 = 48;
export inline const AGG_SIG_UNSAFE: 49 = 49;
export inline const AGG_SIG_ME: 50 = 50;
export inline const CREATE_COIN: 51 = 51;
export inline const RESERVE_FEE: 52 = 52;
export inline const CREATE_COIN_ANNOUNCEMENT: 60 = 60;
export inline const ASSERT_COIN_ANNOUNCEMENT: 61 = 61;
export inline const CREATE_PUZZLE_ANNOUNCEMENT: 62 = 62;
export inline const ASSERT_PUZZLE_ANNOUNCEMENT: 63 = 63;
export inline const ASSERT_CONCURRENT_SPEND: 64 = 64;
export inline const ASSERT_CONCURRENT_PUZZLE: 65 = 65;
export inline const SEND_MESSAGE: 66 = 66;
export inline const RECEIVE_MESSAGE: 67 = 67;
export inline const ASSERT_MY_COIN_ID: 70 = 70;
export inline const ASSERT_MY_PARENT_ID: 71 = 71;
export inline const ASSERT_MY_PUZZLE_HASH: 72 = 72;
export inline const ASSERT_MY_AMOUNT: 73 = 73;
export inline const ASSERT_MY_BIRTH_SECONDS: 74 = 74;
export inline const ASSERT_MY_BIRTH_HEIGHT: 75 = 75;
export inline const ASSERT_EPHEMERAL: 76 = 76;
export inline const ASSERT_SECONDS_RELATIVE: 80 = 80;
export inline const ASSERT_SECONDS_ABSOLUTE: 81 = 81;
export inline const ASSERT_HEIGHT_RELATIVE: 82 = 82;
export inline const ASSERT_HEIGHT_ABSOLUTE: 83 = 83;
export inline const ASSERT_BEFORE_SECONDS_RELATIVE: 84 = 84;
export inline const ASSERT_BEFORE_SECONDS_ABSOLUTE: 85 = 85;
export inline const ASSERT_BEFORE_HEIGHT_RELATIVE: 86 = 86;
export inline const ASSERT_BEFORE_HEIGHT_ABSOLUTE: 87 = 87;
export inline const SOFTFORK: 90 = 90;

export struct Remark {
    opcode = REMARK,
    ...rest: Any,
}

export struct AggSigParent {
    opcode = AGG_SIG_PARENT,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigPuzzle {
    opcode = AGG_SIG_PUZZLE,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigAmount {
    opcode = AGG_SIG_AMOUNT,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigPuzzleAmount {
    opcode = AGG_SIG_PUZZLE_AMOUNT,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigParentAmount {
    opcode = AGG_SIG_PARENT_AMOUNT,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigParentPuzzle {
    opcode = AGG_SIG_PARENT_PUZZLE,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigUnsafe {
    opcode = AGG_SIG_UNSAFE,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigMe {
    opcode = AGG_SIG_ME,
    public_key: PublicKey,
    message: Bytes,
}

export struct CreateCoin {
    opcode = CREATE_COIN,
    puzzle_hash: Bytes32,
    amount: Int,
    ...memos: Memos | nil = nil,
}

export struct Memos {
    value: Any,
}

export struct ReserveFee {
    opcode = RESERVE_FEE,
    amount: Int,
}

export struct CreateCoinAnnouncement {
    opcode = CREATE_COIN_ANNOUNCEMENT,
    message: Bytes,
}

export struct AssertCoinAnnouncement {
    opcode = ASSERT_COIN_ANNOUNCEMENT,
    id: Bytes32,
}

export struct CreatePuzzleAnnouncement {
    opcode = CREATE_PUZZLE_ANNOUNCEMENT,
    message: Bytes,
}

export struct AssertPuzzleAnnouncement {
    opcode = ASSERT_PUZZLE_ANNOUNCEMENT,
    id: Bytes32,
}

export struct AssertConcurrentSpend {
    opcode = ASSERT_CONCURRENT_SPEND,
    coin_id: Bytes32,
}

export struct AssertConcurrentPuzzle {
    opcode = ASSERT_CONCURRENT_PUZZLE,
    puzzle_hash: Bytes32,
}

export struct SendMessage {
    opcode = SEND_MESSAGE,
    mode: Int,
    message: Bytes,
    ...receiver: List<Bytes | Int>,
}

export struct ReceiveMessage {
    opcode = RECEIVE_MESSAGE,
    mode: Int,
    message: Bytes,
    ...sender: List<Bytes | Int>,
}

export struct AssertMyCoinId {
    opcode = ASSERT_MY_COIN_ID,
    coin_id: Bytes32,
}

export struct AssertMyParentId {
    opcode = ASSERT_MY_PARENT_ID,
    parent_id: Bytes32,
}

export struct AssertMyPuzzleHash {
    opcode = ASSERT_MY_PUZZLE_HASH,
    puzzle_hash: Bytes32,
}

export struct AssertMyAmount {
    opcode = ASSERT_MY_AMOUNT,
    amount: Int,
}

export struct AssertMyBirthSeconds {
    opcode = ASSERT_MY_BIRTH_SECONDS,
    seconds: Int,
}

export struct AssertMyBirthHeight {
    opcode = ASSERT_MY_BIRTH_HEIGHT,
    height: Int,
}

export struct AssertEphemeral {
    opcode = ASSERT_EPHEMERAL,
}

export struct AssertSecondsRelative {
    opcode = ASSERT_SECONDS_RELATIVE,
    seconds: Int,
}

export struct AssertSecondsAbsolute {
    opcode = ASSERT_SECONDS_ABSOLUTE,
    seconds: Int,
}

export struct AssertHeightRelative {
    opcode = ASSERT_HEIGHT_RELATIVE,
    height: Int,
}

export struct AssertHeightAbsolute {
    opcode = ASSERT_HEIGHT_ABSOLUTE,
    height: Int,
}

export struct AssertBeforeSecondsRelative {
    opcode = ASSERT_BEFORE_SECONDS_RELATIVE,
    seconds: Int,
}

export struct AssertBeforeSecondsAbsolute {
    opcode = ASSERT_BEFORE_SECONDS_ABSOLUTE,
    seconds: Int,
}

export struct AssertBeforeHeightRelative {
    opcode = ASSERT_BEFORE_HEIGHT_RELATIVE,
    height: Int,
}

export struct AssertBeforeHeightAbsolute {
    opcode = ASSERT_BEFORE_HEIGHT_ABSOLUTE,
    height: Int,
}

export struct Softfork {
    opcode = SOFTFORK,
    cost: Int,
    ...args: List<Any>,
}

export type Condition =
    Remark | AggSigParent | AggSigPuzzle | AggSigAmount
    | AggSigPuzzleAmount | AggSigParentAmount | AggSigParentPuzzle
    | AggSigUnsafe | AggSigMe | CreateCoin | ReserveFee
    | CreateCoinAnnouncement | AssertCoinAnnouncement
    | CreatePuzzleAnnouncement | AssertPuzzleAnnouncement
    | AssertConcurrentSpend | AssertConcurrentPuzzle
    | SendMessage | ReceiveMessage | AssertMyCoinId | AssertMyParentId
    | AssertMyPuzzleHash | AssertMyAmount | AssertMyBirthSeconds
    | AssertMyBirthHeight | AssertEphemeral | AssertSecondsRelative
    | AssertSecondsAbsolute | AssertHeightRelative | AssertHeightAbsolute
    | AssertBeforeSecondsRelative | AssertBeforeSecondsAbsolute
    | AssertBeforeHeightRelative | AssertBeforeHeightAbsolute
    | Softfork;

export fn tree_hash(value: Any) -> Bytes32 {
    if value is Bytes {
        tree_hash_atom(value)
    } else {
        tree_hash_pair(tree_hash(value.first), tree_hash(value.rest))
    }
}

export inline fn tree_hash_atom(value: Bytes) -> Bytes32 {
    sha256(1 as Bytes + value)
}

export inline fn tree_hash_pair(first: Bytes32, rest: Bytes32) -> Bytes32 {
    sha256(2 as Bytes + first + rest)
}

inline fn quote_hash(value: Bytes32) -> Bytes32 {
    tree_hash_pair(tree_hash_atom(1 as Bytes), value)
}

inline fn two_item_list_hash(first: Bytes32, rest: Bytes32) -> Bytes32 {
    tree_hash_pair(first, tree_hash_pair(rest, tree_hash_atom(nil)))
}

inline fn apply_hash(mod_hash: Bytes32, environment_hash: Bytes32) -> Bytes32 {
    sha256(2 as Bytes + tree_hash_atom(2 as Bytes) + two_item_list_hash(quote_hash(mod_hash), environment_hash))
}

inline fn update_hash_with_parameter(
    parameter_hash: Bytes32,
    environment_hash: Bytes32
) -> Bytes32 {
    sha256(2 as Bytes + tree_hash_atom(4 as Bytes) + two_item_list_hash(quote_hash(parameter_hash), environment_hash))
}

fn curried_params_hash(...parameters: List<Bytes32>) -> Bytes32 {
    if parameters is nil {
        return tree_hash_atom(1 as Bytes);
    }
    update_hash_with_parameter(parameters.first, curried_params_hash(...parameters.rest))
}

export inline fn curry_tree_hash(
    mod_hash: Bytes32,
    ...parameters: List<Bytes32>
) -> Bytes32 {
    apply_hash(mod_hash, curried_params_hash(...parameters))
}

export fn merge_list<T>(a: List<T>, b: List<T>) -> List<T> {
    if a is (T, List<T>) {
        return [a.first, ...merge_list(a.rest, b)];
    }
    b
}

export fn deep_equal(a: Any, b: Any) -> Bool {
    if a is Atom {
        if b is Atom {
            a == b
        } else {
            false
        }
    } else {
        if b is Atom {
            false
        } else {
            deep_equal(a.first, b.first) && deep_equal(a.rest, b.rest)
        }
    }
}
