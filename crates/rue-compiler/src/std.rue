export struct Remark {
    opcode = 1,
    ...rest: Any,
}

export struct AggSigParent {
    opcode = 43,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigPuzzle {
    opcode = 44,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigAmount {
    opcode = 45,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigPuzzleAmount {
    opcode = 46,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigParentAmount {
    opcode = 47,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigParentPuzzle {
    opcode = 48,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigUnsafe {
    opcode = 49,
    public_key: PublicKey,
    message: Bytes,
}

export struct AggSigMe {
    opcode = 50,
    public_key: PublicKey,
    message: Bytes,
}

export struct CreateCoin {
    opcode = 51,
    puzzle_hash: Bytes32,
    amount: Int,
    ...memos: Memos | nil = nil,
}

export struct Memos {
    value: Any,
}

export struct ReserveFee {
    opcode = 52,
    amount: Int,
}

export struct CreateCoinAnnouncement {
    opcode = 60,
    message: Bytes,
}

export struct AssertCoinAnnouncement {
    opcode = 61,
    id: Bytes32,
}

export struct CreatePuzzleAnnouncement {
    opcode = 62,
    message: Bytes,
}

export struct AssertPuzzleAnnouncement {
    opcode = 63,
    id: Bytes32,
}

export struct AssertConcurrentSpend {
    opcode = 64,
    coin_id: Bytes32,
}

export struct AssertConcurrentPuzzle {
    opcode = 65,
    puzzle_hash: Bytes32,
}

export struct SendMessage {
    opcode = 66,
    mode: Int,
    message: Bytes,
    ...receiver: List<Bytes | Int>,
}

export struct ReceiveMessage {
    opcode = 67,
    mode: Int,
    message: Bytes,
    ...sender: List<Bytes | Int>,
}

export struct AssertMyCoinId {
    opcode = 70,
    coin_id: Bytes32,
}

export struct AssertMyParentId {
    opcode = 71,
    parent_id: Bytes32,
}

export struct AssertMyPuzzleHash {
    opcode = 72,
    puzzle_hash: Bytes32,
}

export struct AssertMyAmount {
    opcode = 73,
    amount: Int,
}

export struct AssertMyBirthSeconds {
    opcode = 74,
    seconds: Int,
}

export struct AssertMyBirthHeight {
    opcode = 75,
    height: Int,
}

export struct AssertEphemeral {
    opcode = 76,
}

export struct AssertSecondsRelative {
    opcode = 80,
    seconds: Int,
}

export struct AssertSecondsAbsolute {
    opcode = 81,
    seconds: Int,
}

export struct AssertHeightRelative {
    opcode = 82,
    height: Int,
}

export struct AssertHeightAbsolute {
    opcode = 83,
    height: Int,
}

export struct AssertBeforeSecondsRelative {
    opcode = 84,
    seconds: Int,
}

export struct AssertBeforeSecondsAbsolute {
    opcode = 85,
    seconds: Int,
}

export struct AssertBeforeHeightRelative {
    opcode = 86,
    height: Int,
}

export struct AssertBeforeHeightAbsolute {
    opcode = 87,
    height: Int,
}

export struct Softfork {
    opcode = 90,
    cost: Int,
    ...args: List<Any>,
}

export type Condition =
    Remark | AggSigParent | AggSigPuzzle | AggSigAmount
    | AggSigPuzzleAmount | AggSigParentAmount | AggSigParentPuzzle
    | AggSigUnsafe | AggSigMe | CreateCoin | ReserveFee
    | CreateCoinAnnouncement | AssertCoinAnnouncement
    | CreatePuzzleAnnouncement | AssertPuzzleAnnouncement
    | AssertConcurrentSpend | AssertConcurrentPuzzle
    | SendMessage | ReceiveMessage | AssertMyCoinId | AssertMyParentId
    | AssertMyPuzzleHash | AssertMyAmount | AssertMyBirthSeconds
    | AssertMyBirthHeight | AssertEphemeral | AssertSecondsRelative
    | AssertSecondsAbsolute | AssertHeightRelative | AssertHeightAbsolute
    | AssertBeforeSecondsRelative | AssertBeforeSecondsAbsolute
    | AssertBeforeHeightRelative | AssertBeforeHeightAbsolute
    | Softfork;

export fn tree_hash(value: Any) -> Bytes32 {
    if value is Bytes {
        tree_hash_atom(value)
    } else {
        tree_hash_pair(tree_hash(value.first), tree_hash(value.rest))
    }
}

export inline fn tree_hash_atom(value: Bytes) -> Bytes32 {
    sha256(1 as Bytes + value)
}

export inline fn tree_hash_pair(first: Bytes32, rest: Bytes32) -> Bytes32 {
    sha256(2 as Bytes + first + rest)
}

inline fn quote_hash(value: Bytes32) -> Bytes32 {
    tree_hash_pair(tree_hash_atom(1 as Bytes), value)
}

inline fn two_item_list_hash(first: Bytes32, rest: Bytes32) -> Bytes32 {
    tree_hash_pair(first, tree_hash_pair(rest, tree_hash_atom(nil)))
}

inline fn apply_hash(mod_hash: Bytes32, environment_hash: Bytes32) -> Bytes32 {
    sha256(2 as Bytes + tree_hash_atom(2 as Bytes) + two_item_list_hash(quote_hash(mod_hash), environment_hash))
}

inline fn update_hash_with_parameter(
    parameter_hash: Bytes32,
    environment_hash: Bytes32
) -> Bytes32 {
    sha256(2 as Bytes + tree_hash_atom(4 as Bytes) + two_item_list_hash(quote_hash(parameter_hash), environment_hash))
}

fn curried_params_hash(...parameters: List<Bytes32>) -> Bytes32 {
    if parameters is nil {
        return tree_hash_atom(1 as Bytes);
    }
    update_hash_with_parameter(parameters.first, curried_params_hash(...parameters.rest))
}

export inline fn curry_tree_hash(
    mod_hash: Bytes32,
    ...parameters: List<Bytes32>
) -> Bytes32 {
    apply_hash(mod_hash, curried_params_hash(...parameters))
}

export fn merge_list<T>(a: List<T>, b: List<T>) -> List<T> {
    if a is (T, List<T>) {
        return [a.first, ...merge_list(a.rest, b)];
    }
    b
}

export fn deep_equal(a: Any, b: Any) -> Bool {
    if a is Atom {
        if b is Atom {
            a == b
        } else {
            false
        }
    } else {
        if b is Atom {
            false
        } else {
            deep_equal(a.first, b.first) && deep_equal(a.rest, b.rest)
        }
    }
}

export fn map<T, U>(list: List<T>, f: fn(value: T) -> U) -> List<U> {
    if list is nil {
        nil
    } else {
        [f(list.first), ...map(list.rest, f)]
    }
}

export fn filter<T>(list: List<T>, f: fn(value: T) -> Bool) -> List<T> {
    if list is nil {
        nil
    } else if f(list.first) {
        [list.first, ...filter(list.rest, f)]
    } else {
        filter(list.rest, f)
    }
}

export fn reduce<T, U>(list: List<T>, initial: U, f: fn(acc: U, value: T) -> U) -> U {
    if list is nil {
        initial
    } else {
        reduce(list.rest, f(initial, list.first), f)
    }
}

export inline fn mapi<T, U>(list: List<T>, f: fn(value: T, index: Int) -> U) -> List<U> {
    mapi_impl(list, f, 0)
}

fn mapi_impl<T, U>(list: List<T>, f: fn(value: T, index: Int) -> U, index: Int) -> List<U> {
    if list is nil {
        nil
    } else {
        [f(list.first, index), ...mapi_impl(list.rest, f, index + 1)]
    }
}

export inline fn filteri<T>(list: List<T>, f: fn(value: T, index: Int) -> Bool) -> List<T> {
    filteri_impl(list, f, 0)
}

fn filteri_impl<T>(list: List<T>, f: fn(value: T, index: Int) -> Bool, index: Int) -> List<T> {
    if list is nil {
        nil
    } else if f(list.first, index) {
        [list.first, ...filteri_impl(list.rest, f, index + 1)]
    } else {
        filteri_impl(list.rest, f, index + 1)
    }
}
