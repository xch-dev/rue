type List<T> = nil | (T, List<T>);
type Any = Atom | (Any, Any);

struct Remark {
    opcode = 1,
    ...rest: Any,
}

struct AggSigParent {
    opcode = 43,
    public_key: PublicKey,
    message: Bytes,
}

struct AggSigPuzzle {
    opcode = 44,
    public_key: PublicKey,
    message: Bytes,
}

struct AggSigAmount {
    opcode = 45,
    public_key: PublicKey,
    message: Bytes,
}

struct AggSigPuzzleAmount {
    opcode = 46,
    public_key: PublicKey,
    message: Bytes,
}

struct AggSigParentAmount {
    opcode = 47,
    public_key: PublicKey,
    message: Bytes,
}

struct AggSigParentPuzzle {
    opcode = 48,
    public_key: PublicKey,
    message: Bytes,
}

struct AggSigUnsafe {
    opcode = 49,
    public_key: PublicKey,
    message: Bytes,
}

struct AggSigMe {
    opcode = 50,
    public_key: PublicKey,
    message: Bytes,
}

struct CreateCoin {
    opcode = 51,
    puzzle_hash: Bytes32,
    amount: Int,
    ...memos: Memos | nil = nil,
}

struct Memos {
    value: Any,
}

struct ReserveFee {
    opcode = 52,
    amount: Int,
}

struct CreateCoinAnnouncement {
    opcode = 60,
    message: Bytes,
}

struct AssertCoinAnnouncement {
    opcode = 61,
    id: Bytes32,
}

struct CreatePuzzleAnnouncement {
    opcode = 62,
    message: Bytes,
}

struct AssertPuzzleAnnouncement {
    opcode = 63,
    id: Bytes32,
}

struct AssertConcurrentSpend {
    opcode = 64,
    coin_id: Bytes32,
}

struct AssertConcurrentPuzzle {
    opcode = 65,
    puzzle_hash: Bytes32,
}

struct SendMessage {
    opcode = 66,
    mode: Int,
    message: Bytes,
    ...receiver: (Bytes | Int)[],
}

struct ReceiveMessage {
    opcode = 67,
    mode: Int,
    message: Bytes,
    ...sender: (Bytes | Int)[],
}

struct AssertMyCoinId {
    opcode = 70,
    coin_id: Bytes32,
}

struct AssertMyParentId {
    opcode = 71,
    parent_id: Bytes32,
}

struct AssertMyPuzzleHash {
    opcode = 72,
    puzzle_hash: Bytes32,
}

struct AssertMyAmount {
    opcode = 73,
    amount: Int,
}

struct AssertMyBirthSeconds {
    opcode = 74,
    seconds: Int,
}

struct AssertMyBirthHeight {
    opcode = 75,
    height: Int,
}

struct AssertEphemeral {
    opcode = 76,
}

struct AssertSecondsRelative {
    opcode = 80,
    seconds: Int,
}

struct AssertSecondsAbsolute {
    opcode = 81,
    seconds: Int,
}

struct AssertHeightRelative {
    opcode = 82,
    height: Int,
}

struct AssertHeightAbsolute {
    opcode = 83,
    height: Int,
}

struct AssertBeforeSecondsRelative {
    opcode = 84,
    seconds: Int,
}

struct AssertBeforeSecondsAbsolute {
    opcode = 85,
    seconds: Int,
}

struct AssertBeforeHeightRelative {
    opcode = 86,
    height: Int,
}

struct AssertBeforeHeightAbsolute {
    opcode = 87,
    height: Int,
}

struct Softfork {
    opcode = 90,
    cost: Int,
    ...args: List<Any>,
}

type Condition =
    Remark | AggSigParent | AggSigPuzzle | AggSigAmount
    | AggSigPuzzleAmount | AggSigParentAmount | AggSigParentPuzzle
    | AggSigUnsafe | AggSigMe | CreateCoin | ReserveFee
    | CreateCoinAnnouncement | AssertCoinAnnouncement
    | CreatePuzzleAnnouncement | AssertPuzzleAnnouncement
    | AssertConcurrentSpend | AssertConcurrentPuzzle
    | SendMessage | ReceiveMessage | AssertMyCoinId | AssertMyParentId
    | AssertMyPuzzleHash | AssertMyAmount | AssertMyBirthSeconds
    | AssertMyBirthHeight | AssertEphemeral | AssertSecondsRelative
    | AssertSecondsAbsolute | AssertHeightRelative | AssertHeightAbsolute
    | AssertBeforeSecondsRelative | AssertBeforeSecondsAbsolute
    | AssertBeforeHeightRelative | AssertBeforeHeightAbsolute
    | Softfork;

fn tree_hash(value: Any) -> Bytes32 {
    if value is Bytes {
        tree_hash_atom(value)
    } else {
        tree_hash_pair(tree_hash(value.first), tree_hash(value.rest))
    }
}

inline fn tree_hash_atom(value: Bytes) -> Bytes32 {
    sha256(1 as Bytes + value)
}

inline fn tree_hash_pair(first: Bytes32, rest: Bytes32) -> Bytes32 {
    sha256(2 as Bytes + first + rest)
}

inline fn quote_hash(value: Bytes32) -> Bytes32 {
    tree_hash_pair(tree_hash_atom(1 as Bytes), value)
}

inline fn two_item_list_hash(first: Bytes32, rest: Bytes32) -> Bytes32 {
    tree_hash_pair(first, tree_hash_pair(rest, tree_hash_atom(nil)))
}

inline fn apply_hash(mod_hash: Bytes32, environment_hash: Bytes32) -> Bytes32 {
    sha256(2 as Bytes + tree_hash_atom(2 as Bytes) + two_item_list_hash(quote_hash(mod_hash), environment_hash))
}

inline fn update_hash_with_parameter(
    parameter_hash: Bytes32,
    environment_hash: Bytes32
) -> Bytes32 {
    sha256(2 as Bytes + tree_hash_atom(4 as Bytes) + two_item_list_hash(quote_hash(parameter_hash), environment_hash))
}

fn curried_params_hash(parameters: List<Bytes32>) -> Bytes32 {
    if parameters is nil {
        return tree_hash_atom(1 as Bytes);
    }
    update_hash_with_parameter(parameters.first, curried_params_hash(parameters.rest))
}

inline fn curry_tree_hash(
    mod_hash: Bytes32,
    ...parameters: List<Bytes32>
) -> Bytes32 {
    apply_hash(mod_hash, curried_params_hash(parameters))
}
